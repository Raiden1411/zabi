## TypedDataDomain

## MessageProperty

## HashTypedData
Performs hashing of EIP712 according to the expecification
https://eips.ethereum.org/EIPS/eip-712
`types` parameter is expected to be a struct where the struct
keys are used to grab the solidity type information so that the
encoding and hashing can happen based on it. See the specification
for more details.\
`primary_type` is the expected main type that you want to hash this message.\
Compilation will fail if the provided string doesn't exist on the `types` parameter
`domain` is the values of the defined EIP712Domain. Currently it doesnt not support custom
domain types.\
`message` is expected to be a struct where the solidity types are transalated to the native
zig types. I.E string -> []const u8 or int256 -> i256 and so on.\
In the future work will be done where the compiler will offer more clearer types
base on a meta programming type function.

### Signature

```zig
pub fn hashTypedData(allocator: Allocator, comptime types: anytype, comptime primary_type: []const u8, domain: ?TypedDataDomain, message: anytype) ![Keccak256.digest_length]u8
```

## HashStruct
Performs hashing of EIP712 structs according to the expecification
https://eips.ethereum.org/EIPS/eip-712
`types` parameter is expected to be a struct where the struct
keys are used to grab the solidity type information so that the
encoding and hashing can happen based on it. See the specification
for more details.\
`primary_type` is the expected main type that you want to hash this message.\
Compilation will fail if the provided string doesn't exist on the `types` parameter
`data` is expected to be a struct where the solidity types are transalated to the native
zig types. I.E string -> []const u8 or int256 -> i256 and so on.\
In the future work will be done where the compiler will offer more clearer types
base on a meta programming type function.

### Signature

```zig
pub fn hashStruct(allocator: Allocator, comptime types: anytype, comptime primary_type: []const u8, data: anytype) ![Keccak256.digest_length]u8
```

## EncodeStruct
Performs encoding of EIP712 structs according to the expecification
https://eips.ethereum.org/EIPS/eip-712
`types` parameter is expected to be a struct where the struct
keys are used to grab the solidity type information so that the
encoding and hashing can happen based on it. See the specification
for more details.\
`primary_type` is the expected main type that you want to hash this message.\
Compilation will fail if the provided string doesn't exist on the `types` parameter
`data` is expected to be a struct where the solidity types are transalated to the native
zig types. I.E string -> []const u8 or int256 -> i256 and so on.\
In the future work will be done where the compiler will offer more clearer types
base on a meta programming type function.\
Slices, arrays, strings and bytes will all be encoded as "bytes32" instead of their
usual encoded values.

### Signature

```zig
pub fn encodeStruct(allocator: Allocator, comptime types: anytype, comptime primary_type: []const u8, data: anytype, writer: anytype) !void
```

## EncodeStructField
Encodes a singular struct field.

### Signature

```zig
pub fn encodeStructField(allocator: Allocator, comptime types: anytype, comptime primary_type: []const u8, value: anytype, writer: anytype) !void
```

## HashType
Hash the main types and it's nested children

### Signature

```zig
pub fn hashType(allocator: Allocator, comptime types_fields: anytype, comptime primary_type: []const u8) ![Keccak256.digest_length]u8
```

## EncodeType
Encodes the main type from a struct into a "human-readable" format.\
*Ex: struct { Mail: []const struct {type: "address", name: "foo"}} into "Mail(address foo)"*

### Signature

```zig
pub fn encodeType(allocator: Allocator, comptime types_fields: anytype, comptime primary_type: []const u8, writer: anytype) !void
```

## FindTypeDependencies
Finds the main type child type and recursivly checks their children as well.

### Signature

```zig
pub fn findTypeDependencies(comptime types_fields: anytype, comptime primary_type: []const u8, result: *std.StringArrayHashMap(void)) Allocator.Error!void
```

