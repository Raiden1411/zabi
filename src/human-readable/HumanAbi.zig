const abi = zabi_abi.abitypes;
const param = zabi_abi.abi_parameter;
const param_types = zabi_abi.param_type;
const std = @import("std");
const tokens = @import("tokens.zig");
const zabi_abi = @import("zabi-abi");

const AbiParameter = param.AbiParameter;
const AbiEventParameter = param.AbiEventParameter;
const Allocator = std.mem.Allocator;
const Abi = abi.Abi;
const AbiConstructor = abi.Constructor;
const AbiEvent = abi.Event;
const AbiError = abi.Error;
const AbiItem = abi.AbiItem;
const AbiFallback = abi.Fallback;
const AbiFunction = abi.Function;
const AbiReceive = abi.Receive;
const Ast = @import("Ast.zig");
const Node = Ast.Node;
const ParamErrors = param_types.ParamErrors;
const ParamType = param_types.ParamType;
const Parser = @import("Parser.zig");
const StateMutability = zabi_abi.abitypes.StateMutability;

/// Set of errors when converting to the abi
pub const HumanAbiErrors = ParamErrors || Allocator.Error || error{ NoSpaceLeft, MissingTypeDeclaration };

/// Set of erros when generating the ABI
pub const Errors = HumanAbiErrors || Parser.ParserErrors || error{ UnexpectedMutability, UnexpectedNode };

const HumanAbi = @This();

/// Allocator to use to generate the ABI.
/// It's recommend to use an `ArenaAllocator` for this.
allocator: Allocator,
/// Ast generated by the parser so that we can use to generate the ABI.
ast: *const Ast,
/// Set of `AbiParameter` components by the struct type.
struct_params: std.StringArrayHashMapUnmanaged([]const AbiParameter),

/// Parses the source, builds the Ast and generates the ABI.
///
/// It's recommend to use an `ArenaAllocator` for this.
pub fn parse(arena: Allocator, source: [:0]const u8) Errors!Abi {
    var ast = try Ast.parse(arena, source);
    defer ast.deinit(arena);

    var abi_gen: HumanAbi = .{
        .allocator = arena,
        .ast = &ast,
        .struct_params = .empty,
    };
    defer abi_gen.struct_params.deinit(arena);

    return abi_gen.toAbi();
}
/// Generates the `Abi` from the ast nodes.
pub fn toAbi(self: *HumanAbi) (HumanAbiErrors || error{ UnexpectedNode, UnexpectedMutability })!Abi {
    const nodes = self.ast.nodes.items(.tag);
    const data = self.ast.nodes.items(.data);

    var list = try std.ArrayList(AbiItem).initCapacity(self.allocator, self.ast.nodes.len);
    errdefer list.deinit();

    for (nodes, 0..) |node, index| {
        switch (node) {
            .function_proto,
            .function_proto_one,
            .function_proto_multi,
            .function_proto_simple,
            .event_proto_multi,
            .event_proto_simple,
            .error_proto_multi,
            .error_proto_simple,
            .constructor_proto_multi,
            .constructor_proto_simple,
            .fallback_proto_multi,
            .fallback_proto_simple,
            .receive_proto,
            => list.appendAssumeCapacity(try self.toAbiItem(@intCast(index))),
            .struct_decl_one,
            => {
                const struct_param = try self.toStructComponentsOne(@intCast(index));
                const name = self.ast.tokenSlice(data[@intCast(index)].lhs);

                try self.struct_params.put(self.allocator, name, struct_param);
            },
            .struct_decl,
            => {
                const struct_param = try self.toStructComponents(@intCast(index));
                const name = self.ast.tokenSlice(data[@intCast(index)].lhs);

                try self.struct_params.put(self.allocator, name, struct_param);
            },
            else => continue,
        }
    }

    list.shrinkAndFree(list.items.len);

    return list.toOwnedSlice();
}
/// Generates an `AbiItem` based on the provided node. Not all nodes are supported.
pub fn toAbiItem(self: HumanAbi, node: Node.Index) (HumanAbiErrors || error{ UnexpectedNode, UnexpectedMutability })!AbiItem {
    const nodes = self.ast.nodes.items(.tag);

    return switch (nodes[node]) {
        .function_proto => .{ .abiFunction = try self.toAbiFunction(node) },
        .function_proto_one => .{ .abiFunction = try self.toAbiFunctionOne(node) },
        .function_proto_multi => .{ .abiFunction = try self.toAbiFunctionMulti(node) },
        .function_proto_simple => .{ .abiFunction = try self.toAbiFunctionSimple(node) },
        .event_proto_multi => .{ .abiEvent = try self.toAbiEventMulti(node) },
        .event_proto_simple => .{ .abiEvent = try self.toAbiEventSimple(node) },
        .error_proto_multi => .{ .abiError = try self.toAbiErrorMulti(node) },
        .error_proto_simple => .{ .abiError = try self.toAbiErrorSimple(node) },
        .constructor_proto_multi => .{ .abiConstructor = try self.toAbiConstructorMulti(node) },
        .constructor_proto_simple => .{ .abiConstructor = try self.toAbiConstructorSimple(node) },
        .fallback_proto_multi => .{ .abiFallback = try self.toAbiFallbackMulti(node) },
        .fallback_proto_simple => .{ .abiFallback = try self.toAbiFallbackSimple(node) },
        .receive_proto => .{ .abiReceive = try self.toAbiReceive(node) },
        else => error.UnexpectedNode,
    };
}
/// Generates a `AbiFunction` from a `function_proto`.
pub fn toAbiFunction(self: HumanAbi, node: Node.Index) HumanAbiErrors!AbiFunction {
    const nodes = self.ast.nodes.items(.tag);
    std.debug.assert(nodes[node] == .function_proto);

    const ast_function = self.ast.functionProto(node);
    std.debug.assert(ast_function.ast.return_params != null);

    const params = try self.toAbiParameters(ast_function.ast.params);
    const returns = try self.toAbiParameters(ast_function.ast.return_params.?);

    const mutability: StateMutability = blk: {
        if (ast_function.payable != null)
            break :blk .payable;

        if (ast_function.view != null)
            break :blk .view;

        if (ast_function.pure != null)
            break :blk .pure;

        break :blk .nonpayable;
    };

    return .{
        .type = .function,
        .name = self.ast.tokenSlice(ast_function.name),
        .inputs = params,
        .stateMutability = mutability,
        .outputs = returns,
    };
}
/// Generates a `AbiFunction` from a `function_proto_one`.
pub fn toAbiFunctionOne(self: HumanAbi, node: Node.Index) HumanAbiErrors!AbiFunction {
    const nodes = self.ast.nodes.items(.tag);
    std.debug.assert(nodes[node] == .function_proto_one);

    var buffer: [1]Node.Index = undefined;
    const ast_function = self.ast.functionProtoOne(&buffer, node);
    std.debug.assert(ast_function.ast.return_params != null);

    const params = try self.toAbiParameters(ast_function.ast.params);
    const returns = try self.toAbiParameters(ast_function.ast.return_params.?);

    const mutability: StateMutability = blk: {
        if (ast_function.payable != null)
            break :blk .payable;

        if (ast_function.view != null)
            break :blk .view;

        if (ast_function.pure != null)
            break :blk .pure;

        break :blk .nonpayable;
    };

    return .{
        .type = .function,
        .name = self.ast.tokenSlice(ast_function.name),
        .inputs = params,
        .stateMutability = mutability,
        .outputs = returns,
    };
}
/// Generates a `AbiFunction` from a `function_proto_multi`.
pub fn toAbiFunctionMulti(self: HumanAbi, node: Node.Index) HumanAbiErrors!AbiFunction {
    const nodes = self.ast.nodes.items(.tag);
    std.debug.assert(nodes[node] == .function_proto_multi);

    const ast_function = self.ast.functionProtoMulti(node);
    std.debug.assert(ast_function.ast.return_params == null);

    const params = try self.toAbiParameters(ast_function.ast.params);

    const mutability: StateMutability = blk: {
        if (ast_function.payable != null)
            break :blk .payable;

        if (ast_function.view != null)
            break :blk .view;

        if (ast_function.pure != null)
            break :blk .pure;

        break :blk .nonpayable;
    };

    return .{
        .type = .function,
        .name = self.ast.tokenSlice(ast_function.name),
        .inputs = params,
        .stateMutability = mutability,
        .outputs = &.{},
    };
}
/// Generates a `AbiFunction` from a `function_proto_simple`.
pub fn toAbiFunctionSimple(self: HumanAbi, node: Node.Index) HumanAbiErrors!AbiFunction {
    const nodes = self.ast.nodes.items(.tag);
    std.debug.assert(nodes[node] == .function_proto_simple);

    var buffer: [1]Node.Index = undefined;
    const ast_function = self.ast.functionProtoSimple(&buffer, node);
    std.debug.assert(ast_function.ast.return_params == null);

    const params = try self.toAbiParameters(ast_function.ast.params);

    const mutability: StateMutability = blk: {
        if (ast_function.payable != null)
            break :blk .payable;

        if (ast_function.view != null)
            break :blk .view;

        if (ast_function.pure != null)
            break :blk .pure;

        break :blk .nonpayable;
    };

    return .{
        .type = .function,
        .name = self.ast.tokenSlice(ast_function.name),
        .inputs = params,
        .stateMutability = mutability,
        .outputs = &.{},
    };
}
/// Generates a `AbiParameter` as a tuple with the components.
///
/// It gets generated from a `struct_decl` node.
pub fn toStructComponents(self: HumanAbi, node: Node.Index) HumanAbiErrors![]const AbiParameter {
    const nodes = self.ast.nodes.items(.tag);
    std.debug.assert(nodes[node] == .struct_decl);

    const struct_decl = self.ast.structDecl(node);

    const params = try self.toAbiParametersFromDecl(struct_decl.ast.members);

    return params;
}
/// Generates a `AbiParameter` as a tuple with the components.
///
/// It gets generated from a `struct_decl_one` node.
pub fn toStructComponentsOne(self: HumanAbi, node: Node.Index) HumanAbiErrors![]const AbiParameter {
    const nodes = self.ast.nodes.items(.tag);
    std.debug.assert(nodes[node] == .struct_decl_one);

    var buffer: [1]Node.Index = undefined;
    const struct_decl = self.ast.structDeclOne(&buffer, node);

    const params = try self.toAbiParametersFromDecl(struct_decl.ast.members);

    return params;
}
/// Generates a `AbiConstructor` from a `constructor_proto_multi`.
pub fn toAbiConstructorMulti(self: HumanAbi, node: Node.Index) HumanAbiErrors!AbiConstructor {
    const nodes = self.ast.nodes.items(.tag);
    std.debug.assert(nodes[node] == .constructor_proto_multi);

    const ast_constructor = self.ast.constructorProtoMulti(node);

    const params = try self.toAbiParameters(ast_constructor.ast.params);

    return .{
        .type = .constructor,
        .inputs = params,
        .stateMutability = if (ast_constructor.payable != null) .payable else .nonpayable,
    };
}
/// Generates a `AbiConstructor` from a `constructor_proto_simple`.
pub fn toAbiConstructorSimple(self: HumanAbi, node: Node.Index) HumanAbiErrors!AbiConstructor {
    const nodes = self.ast.nodes.items(.tag);
    std.debug.assert(nodes[node] == .constructor_proto_simple);

    var buffer: [1]Node.Index = undefined;
    const ast_constructor = self.ast.constructorProtoSimple(&buffer, node);

    const params = try self.toAbiParameters(ast_constructor.ast.params);

    return .{
        .type = .constructor,
        .inputs = params,
        .stateMutability = if (ast_constructor.payable != null) .payable else .nonpayable,
    };
}
/// Generates a `AbiEvent` from a `event_proto_multi`.
pub fn toAbiEventMulti(self: HumanAbi, node: Node.Index) HumanAbiErrors!AbiEvent {
    const nodes = self.ast.nodes.items(.tag);
    std.debug.assert(nodes[node] == .event_proto_multi);

    const ast_event = self.ast.eventProtoMulti(node);

    const params = try self.toAbiEventParameters(ast_event.ast.params);

    return .{
        .type = .event,
        .name = self.ast.tokenSlice(ast_event.name),
        .inputs = params,
    };
}
/// Generates a `AbiEvent` from a `event_proto_simple`.
pub fn toAbiEventSimple(self: HumanAbi, node: Node.Index) HumanAbiErrors!AbiEvent {
    const nodes = self.ast.nodes.items(.tag);
    std.debug.assert(nodes[node] == .event_proto_simple);

    var buffer: [1]Node.Index = undefined;
    const ast_event = self.ast.eventProtoSimple(&buffer, node);

    const params = try self.toAbiEventParameters(ast_event.ast.params);

    return .{
        .type = .event,
        .name = self.ast.tokenSlice(ast_event.name),
        .inputs = params,
    };
}
/// Generates a `AbiError` from a `error_proto_multi`.
pub fn toAbiErrorMulti(self: HumanAbi, node: Node.Index) HumanAbiErrors!AbiError {
    const nodes = self.ast.nodes.items(.tag);
    std.debug.assert(nodes[node] == .error_proto_multi);

    const ast_error = self.ast.errorProtoMulti(node);

    const params = try self.toAbiParametersFromDecl(ast_error.ast.params);

    return .{
        .type = .@"error",
        .name = self.ast.tokenSlice(ast_error.name),
        .inputs = params,
    };
}
/// Generates a `AbiError` from a `error_proto_simple`.
pub fn toAbiErrorSimple(self: HumanAbi, node: Node.Index) HumanAbiErrors!AbiError {
    const nodes = self.ast.nodes.items(.tag);
    std.debug.assert(nodes[node] == .error_proto_simple);

    var buffer: [1]Node.Index = undefined;
    const ast_error = self.ast.errorProtoSimple(&buffer, node);

    const params = try self.toAbiParametersFromDecl(ast_error.ast.params);

    return .{
        .type = .@"error",
        .name = self.ast.tokenSlice(ast_error.name),
        .inputs = params,
    };
}
/// Generates a `[]const AbiParameter` from a slice of `var_decl`.
pub fn toAbiParameters(self: HumanAbi, nodes: []const Node.Index) HumanAbiErrors![]const AbiParameter {
    var params = try std.ArrayList(AbiParameter).initCapacity(self.allocator, nodes.len);
    errdefer params.deinit();

    for (nodes) |node| {
        params.appendAssumeCapacity(try self.toAbiParameter(node));
    }

    return params.toOwnedSlice();
}
/// Generates a `[]const AbiEventParameter` from a slice of `struct_field` or `error_var_decl`.
pub fn toAbiParametersFromDecl(self: HumanAbi, nodes: []const Node.Index) HumanAbiErrors![]const AbiParameter {
    var params = try std.ArrayList(AbiParameter).initCapacity(self.allocator, nodes.len);
    errdefer params.deinit();

    for (nodes) |node| {
        params.appendAssumeCapacity(try self.toAbiParameterFromDecl(node));
    }

    return params.toOwnedSlice();
}
/// Generates a `[]const AbiEventParameter` from a slice of `event_var_decl`.
pub fn toAbiEventParameters(self: HumanAbi, nodes: []const Node.Index) HumanAbiErrors![]const AbiEventParameter {
    var params = try std.ArrayList(AbiEventParameter).initCapacity(self.allocator, nodes.len);
    errdefer params.deinit();

    for (nodes) |node| {
        params.appendAssumeCapacity(try self.toAbiEventParameter(node));
    }

    return params.toOwnedSlice();
}
/// Generates a `AbiParameter` from a `var_decl`.
pub fn toAbiParameter(self: HumanAbi, node: Node.Index) HumanAbiErrors!AbiParameter {
    const nodes = self.ast.nodes.items(.tag);
    const data = self.ast.nodes.items(.data);
    const main = self.ast.nodes.items(.main_token);
    const starts = self.ast.tokens.items(.start);
    const token_tags = self.ast.tokens.items(.tag);

    std.debug.assert(nodes[node] == .var_decl);

    switch (nodes[data[node].lhs]) {
        .array_type => {
            const array_type = data[node].lhs;

            switch (nodes[data[array_type].lhs]) {
                .tuple_type,
                .tuple_type_one,
                => {
                    const open_bracket = starts[main[data[node].lhs]];
                    const closing_bracket = starts[data[data[node].lhs].rhs] + 1;

                    var buffer: [256]u8 = undefined;
                    const slice = try std.fmt.bufPrint(&buffer, "tuple{s}", .{self.ast.source[open_bracket..closing_bracket]});

                    const param_type = try ParamType.typeToUnionWithTag(self.allocator, slice, .Tuple);
                    const components = try self.toAbiComponents(data[array_type].lhs);

                    return .{
                        .type = param_type,
                        .name = if (data[node].rhs == 0) "" else self.ast.tokenSlice(data[node].rhs),
                        .components = components,
                    };
                },
                .struct_type => {
                    const open_bracket = starts[main[data[node].lhs]];
                    const closing_bracket = starts[data[data[node].lhs].rhs] + 1;

                    var buffer: [256]u8 = undefined;
                    const slice = try std.fmt.bufPrint(&buffer, "tuple{s}", .{self.ast.source[open_bracket..closing_bracket]});

                    const param_type = try ParamType.typeToUnionWithTag(self.allocator, slice, .Tuple);
                    const components = self.struct_params.get(self.ast.tokenSlice(main[data[array_type].lhs])) orelse return error.MissingTypeDeclaration;

                    return .{
                        .type = param_type,
                        .name = if (data[node].rhs == 0) "" else self.ast.tokenSlice(data[node].rhs),
                        .components = components,
                    };
                },
                else => {
                    const type_slice = self.ast.getNodeSource(data[node].lhs);
                    const param_type = try ParamType.typeToUnionWithTag(self.allocator, type_slice, token_tags[main[data[array_type].lhs]]);

                    return .{
                        .type = param_type,
                        .name = if (main[node] == 0) "" else self.ast.tokenSlice(main[node]),
                    };
                },
            }
        },
        .tuple_type_one,
        .tuple_type,
        => {
            const components = try self.toAbiComponents(data[node].lhs);

            return .{
                .type = .{ .tuple = {} },
                .name = if (data[node].rhs == 0) "" else self.ast.tokenSlice(data[node].rhs),
                .components = components,
            };
        },
        .elementary_type => {
            const param_type = ParamType.fromHumanReadableTokenTag(token_tags[main[data[node].lhs]]).?;

            return .{
                .type = param_type,
                .name = if (data[node].rhs == 0) "" else self.ast.tokenSlice(data[node].rhs),
            };
        },
        .struct_type => {
            const components = self.struct_params.get(self.ast.tokenSlice(main[data[node].lhs])) orelse return error.MissingTypeDeclaration;

            return .{
                .type = .{ .tuple = {} },
                .name = if (data[node].rhs == 0) "" else self.ast.tokenSlice(data[node].rhs),
                .components = components,
            };
        },
        else => unreachable, // Invalid Node.
    }
}
/// Generates a `[]const AbiParameter` or in other words generates the tuple components.
///
/// It is expecting the node to be a `tuple_type` or a `tuple_type_one`.
pub fn toAbiComponents(self: HumanAbi, node: Node.Index) HumanAbiErrors![]const AbiParameter {
    const nodes = self.ast.nodes.items(.tag);
    const data = self.ast.nodes.items(.data);
    std.debug.assert(nodes[node] == .tuple_type or nodes[node] == .tuple_type_one);

    if (nodes[node] == .tuple_type_one) {
        var buffer: [1]Node.Index = undefined;
        buffer[0] = data[node].lhs;

        const components = try self.toAbiParametersFromDecl(if (data[node].lhs == 0) buffer[0..0] else buffer[0..1]);

        return components;
    }

    const extra = self.ast.extraData(Ast.Node.Range, data[node].lhs);
    const components = try self.toAbiParametersFromDecl(self.ast.extra_data[extra.start..extra.end]);

    return components;
}
/// Generates a `AbiEventParameter` from a `event_var_decl`.
pub fn toAbiEventParameter(self: HumanAbi, node: Node.Index) HumanAbiErrors!AbiEventParameter {
    const nodes = self.ast.nodes.items(.tag);
    const data = self.ast.nodes.items(.data);
    const main = self.ast.nodes.items(.main_token);
    const starts = self.ast.tokens.items(.start);
    const token_tags = self.ast.tokens.items(.tag);

    std.debug.assert(nodes[node] == .event_var_decl);

    switch (nodes[data[node].lhs]) {
        .array_type => {
            const array_type = data[node].lhs;

            switch (nodes[data[array_type].lhs]) {
                .tuple_type,
                .tuple_type_one,
                => {
                    const open_bracket = starts[main[data[node].lhs]];
                    const closing_bracket = starts[data[data[node].lhs].rhs] + 1;

                    var buffer: [256]u8 = undefined;
                    const slice = try std.fmt.bufPrint(&buffer, "tuple{s}", .{self.ast.source[open_bracket..closing_bracket]});

                    const param_type = try ParamType.typeToUnionWithTag(self.allocator, slice, .Tuple);
                    const components = try self.toAbiComponents(data[array_type].lhs);

                    return .{
                        .type = param_type,
                        .name = if (data[node].rhs == 0) "" else self.ast.tokenSlice(data[node].rhs),
                        .indexed = if (main[node] != 0) true else false,
                        .components = components,
                    };
                },
                .struct_type => {
                    const open_bracket = starts[main[data[node].lhs]];
                    const closing_bracket = starts[data[data[node].lhs].rhs] + 1;

                    var buffer: [256]u8 = undefined;
                    const slice = try std.fmt.bufPrint(&buffer, "tuple{s}", .{self.ast.source[open_bracket..closing_bracket]});

                    const param_type = try ParamType.typeToUnionWithTag(self.allocator, slice, .Tuple);
                    const components = self.struct_params.get(self.ast.tokenSlice(main[data[array_type].lhs])) orelse return error.MissingTypeDeclaration;

                    return .{
                        .type = param_type,
                        .name = if (data[node].rhs == 0) "" else self.ast.tokenSlice(data[node].rhs),
                        .indexed = if (main[node] != 0) true else false,
                        .components = components,
                    };
                },
                else => {
                    const type_slice = self.ast.getNodeSource(data[node].lhs);
                    const param_type = try ParamType.typeToUnionWithTag(self.allocator, type_slice, token_tags[main[data[array_type].lhs]]);

                    return .{
                        .type = param_type,
                        .indexed = if (main[node] != 0) true else false,
                        .name = if (main[node] == 0) "" else self.ast.tokenSlice(main[node]),
                    };
                },
            }
        },
        .tuple_type_one,
        .tuple_type,
        => {
            const components = try self.toAbiComponents(data[node].lhs);

            return .{
                .type = .{ .tuple = {} },
                .name = if (data[node].rhs == 0) "" else self.ast.tokenSlice(data[node].rhs),
                .indexed = if (main[node] != 0) true else false,
                .components = components,
            };
        },
        .elementary_type => {
            const param_type = ParamType.fromHumanReadableTokenTag(token_tags[main[data[node].lhs]]).?;

            return .{
                .type = param_type,
                .name = if (data[node].rhs == 0) "" else self.ast.tokenSlice(data[node].rhs),
                .indexed = if (main[node] != 0) true else false,
            };
        },
        .struct_type => {
            const components = self.struct_params.get(self.ast.tokenSlice(main[data[node].lhs])) orelse return error.MissingTypeDeclaration;

            return .{
                .type = .{ .tuple = {} },
                .name = if (data[node].rhs == 0) "" else self.ast.tokenSlice(data[node].rhs),
                .indexed = if (main[node] != 0) true else false,
                .components = components,
            };
        },
        else => unreachable, // Invalid Node.
    }
}
/// Generates a `AbiParameter` from a `error_var_decl` or a `struct_field`.
pub fn toAbiParameterFromDecl(self: HumanAbi, node: Node.Index) HumanAbiErrors!AbiParameter {
    const nodes = self.ast.nodes.items(.tag);
    const data = self.ast.nodes.items(.data);
    const main = self.ast.nodes.items(.main_token);
    const starts = self.ast.tokens.items(.start);
    const token_tags = self.ast.tokens.items(.tag);

    std.debug.assert(nodes[node] == .error_var_decl or nodes[node] == .struct_field);

    switch (nodes[data[node].lhs]) {
        .array_type => {
            const array_type = data[node].lhs;

            switch (nodes[data[array_type].lhs]) {
                .tuple_type,
                .tuple_type_one,
                => {
                    const open_bracket = starts[main[data[node].lhs]];
                    const closing_bracket = starts[data[data[node].lhs].rhs] + 1;

                    var buffer: [256]u8 = undefined;
                    const slice = try std.fmt.bufPrint(&buffer, "tuple{s}", .{self.ast.source[open_bracket..closing_bracket]});

                    const param_type = try ParamType.typeToUnionWithTag(self.allocator, slice, .Tuple);
                    const components = try self.toAbiComponents(data[array_type].lhs);

                    return .{
                        .type = param_type,
                        .name = if (main[node] == 0) "" else self.ast.tokenSlice(main[node]),
                        .components = components,
                    };
                },
                .struct_type => {
                    const open_bracket = starts[main[data[node].lhs]];
                    const closing_bracket = starts[data[data[node].lhs].rhs] + 1;

                    var buffer: [256]u8 = undefined;
                    const slice = try std.fmt.bufPrint(&buffer, "tuple{s}", .{self.ast.source[open_bracket..closing_bracket]});

                    const param_type = try ParamType.typeToUnionWithTag(self.allocator, slice, .Tuple);
                    const components = self.struct_params.get(self.ast.tokenSlice(main[data[array_type].lhs])) orelse return error.MissingTypeDeclaration;

                    return .{
                        .type = param_type,
                        .name = if (main[node] == 0) "" else self.ast.tokenSlice(main[node]),
                        .components = components,
                    };
                },
                else => {
                    const type_slice = self.ast.getNodeSource(data[node].lhs);
                    const param_type = try ParamType.typeToUnionWithTag(self.allocator, type_slice, token_tags[main[data[array_type].lhs]]);

                    return .{
                        .type = param_type,
                        .name = if (main[node] == 0) "" else self.ast.tokenSlice(main[node]),
                    };
                },
            }
        },
        .tuple_type_one,
        .tuple_type,
        => {
            const components = try self.toAbiComponents(data[node].lhs);

            return .{
                .type = .{ .tuple = {} },
                .name = if (main[node] == 0) "" else self.ast.tokenSlice(main[node]),
                .components = components,
            };
        },
        .elementary_type => {
            const param_type = ParamType.fromHumanReadableTokenTag(token_tags[main[data[node].lhs]]).?;

            return .{
                .type = param_type,
                .name = if (main[node] == 0) "" else self.ast.tokenSlice(main[node]),
            };
        },
        .struct_type => {
            const components = self.struct_params.get(self.ast.tokenSlice(main[data[node].lhs])) orelse return error.MissingTypeDeclaration;

            return .{
                .type = .{ .tuple = {} },
                .name = if (main[node] == 0) "" else self.ast.tokenSlice(main[node]),
                .components = components,
            };
        },
        else => unreachable, // Invalid Node.
    }
}
/// Generates a `AbiFallback` from a `fallback_proto_multi`.
pub fn toAbiFallbackMulti(self: HumanAbi, node: Node.Index) Allocator.Error!AbiFallback {
    const nodes = self.ast.nodes.items(.tag);
    std.debug.assert(nodes[node] == .fallback_proto_multi);

    const ast_fallback = self.ast.fallbackProtoMulti(node);

    return .{
        .type = .fallback,
        .stateMutability = if (ast_fallback.payable != null) .payable else .nonpayable,
    };
}
/// Generates a `AbiFallback` from a `fallback_proto_simple`.
pub fn toAbiFallbackSimple(self: HumanAbi, node: Node.Index) Allocator.Error!AbiFallback {
    const nodes = self.ast.nodes.items(.tag);
    std.debug.assert(nodes[node] == .fallback_proto_simple);

    var buffer: [1]Node.Index = undefined;
    const ast_fallback = self.ast.fallbackProtoSimple(&buffer, node);

    return .{
        .type = .fallback,
        .stateMutability = if (ast_fallback.payable != null) .payable else .nonpayable,
    };
}
/// Generates a `AbiReceive` from a `receive_proto`.
pub fn toAbiReceive(self: HumanAbi, node: Node.Index) (Allocator.Error || error{UnexpectedMutability})!AbiReceive {
    const nodes = self.ast.nodes.items(.tag);
    std.debug.assert(nodes[node] == .receive_proto);

    const ast_receive = self.ast.receiveProto(node);

    return .{
        .type = .receive,
        .stateMutability = if (ast_receive.payable == null) return error.UnexpectedMutability else .payable,
    };
}
